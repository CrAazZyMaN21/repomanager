# La fonction a besoin de 3 paramètres pour fonctionner :
# Le nom du repo
# Le nom de la distribution
# Le nom de la section
# La date de la section
# La description de la section
# Si aucun paramètre n'a été passé, alors on les demande (on affiche la liste des repos d'abord, pour aider):
if [ $# -eq "0" ];then
	listOldRepo
	echo -e "Informations sur le repo à restaurer :"
	infoRepo "+repo-name" "+repo-date" "+repo-description"
else # Sinon on les récupère dans des variables REPO_*
	while [ $# -ge 1 ];do case "$1" in
		--repo-name)
			REPO_NAME="$2"
			shift
		;;
		--repo-date)
			REPO_DATE="$2"
			shift
		;;
        --repo-description)
            # on shift un coup pour récupérer tous les derniers arguments $* (la description pouvant contenir des espaces, chaque espace est un nouvel argument, c'est pour ça qu'on récupère tout)
			shift
			REPO_DESCRIPTION="$*"
			if [ "$REPO_DESCRIPTION" == "null" ];then REPO_DESCRIPTION="";fi # Si la description est égale à 'nodescription' alors elle doit être laissée vide
        ;;
		*)
		esac
		shift
	done
fi
if egrep -q "^${REPO_NAME}:${REPO_DATE}" $LISTE_REPO_ARCHIVE;then  # On vérifie que le repo renseigné est bien présent dans le fichier repos-archive.list, alors on peut commencer l'opération
	DATE_QUI_SERA_REMPLACE=$(egrep "^${REPO_NAME}:prod:" "$LISTE_REPO" | awk -F: '{print $3}') # Date du repo en prod actuel qui sera remplacé
	if [ -z "$DATE_QUI_SERA_REMPLACE" ];then
		echo -ne "Actuellement il n'y a aucune version en prod du repo ${CYAN}${REPO_NAME}${RESET}, l'opération va donc restaurer directement celle du ${CYAN}${REPO_DATE}${RESET}."
	else
		echo -ne "L'ancienne version du repo ${CYAN}${REPO_NAME}${RESET} à la date du ${CYAN}${REPO_DATE}${RESET} remplacera celle du ${ROUGE}${DATE_QUI_SERA_REMPLACE}${RESET} qui est actuellement en production."
	fi
    echo -ne " Confirmer (oui/non) : ";read -p "" CONFIRM
    if [ "$CONFIRM" != "oui" ];then # Si différent de oui, alors le script s'arrête
        echo -e "Arrêt du script..."
        clean_exit
    fi
	echo -e "\nDébut de l'opération" && sleep 1 &&
	cd ${REPOS_DIR}/ &&
	echo -ne "Suppression du lien symbolique :\t" &&
	unlink ${REPO_NAME}_prod && # Suppression du lien symbolique
    echo -e "[${VERT} OK ${RESET}]"
	echo -ne "Remise en place de l'ancien snapshot :\t" &&
	mv 99_old_version_${REPO_DATE}_${REPO_NAME} ${REPO_DATE}_${REPO_NAME} &&
    echo -e "[${VERT} OK ${RESET}]" &&
	echo -ne "Création du lien symbolique :\t" &&
	ln -s ${REPO_DATE}_${REPO_NAME}/ ${REPO_NAME}_prod &&
	echo -e "[${VERT} OK ${RESET}]" &&

	# Note : s'inspirer de ce qui a été fait pour Debian pour les opérations ci dessous : 
	if [ -z "$DATE_QUI_SERA_REMPLACE" ];then # Si il n'y avait aucune version actuellement en prod, alors il n'y a pas d'archivage a faire
		echo -ne "Mise à jour des informations dans repos.list :\t" &&
		echo "${REPO_NAME}:prod:${REPO_DATE}:${REPO_DESCRIPTION}" >> $LISTE_REPO &&
		echo -e "[${VERT} OK ${RESET}]"
		echo -ne "Mise à jour des informations dans repos-archive.list :\t" &&
        sed -i /^${REPO_NAME}:${REPO_DATE}/d $LISTE_REPO_ARCHIVE &&
		echo -e "[${VERT} OK ${RESET}]"
	elif grep -q "^${REPO_NAME}:test:${DATE_QUI_SERA_REMPLACE}:" $LISTE_REPO;then	# Si le snapshot actuel est encore utilisé en test, alors on ne l'archive pas
		echo -e "\nLe snapshot ${CYAN}${DATE_QUI_SERA_REMPLACE}_${REPO_NAME}${RESET} est toujours utilisé en test, donc on ne l'archive pas"
		echo -ne "Mise à jour des informations dans repos.list :\t" &&
		sed -i /^${REPO_NAME}:prod:${DATE_QUI_SERA_REMPLACE}/d $LISTE_REPO && # On mets à jour les infos dans le fichier de conf
		echo "${REPO_NAME}:prod:${REPO_DATE}:${REPO_DESCRIPTION}" >> $LISTE_REPO &&
        echo -e "[${VERT} OK ${RESET}]"
		echo -ne "Mise à jour des informations dans repos-archive.list :\t" &&
		sed -i /^${REPO_NAME}:${REPO_DATE}/d $LISTE_REPO_ARCHIVE &&		# Suppression des infos du repo dans repos-archive.list puisqu'on vient de le restaurer en prod
		echo -e "[${VERT} OK ${RESET}]"
	else	# Sinon il n'est plus utilisé en prod ni en test, alors on l'archive 
		OLD_DESC_PROD=$(egrep "^${REPO_NAME}:prod:${DATE_QUI_SERA_REMPLACE}" "$LISTE_REPO" | awk -F: '{print $4}') &&
		echo -ne "Archivage du snapshot ${CYAN}${DATE_QUI_SERA_REMPLACE}_${REPO_NAME}${RESET} (non utilisé) :\t" &&
		mv ${DATE_QUI_SERA_REMPLACE}_${REPO_NAME}/ 99_old_version_${DATE_QUI_SERA_REMPLACE}_${REPO_NAME}
		echo -e "[${VERT} OK ${RESET}]" &&
		echo -ne "Mise à jour des informations dans repos.list :\t" &&
		sed -i s/^${REPO_NAME}:prod:${DATE_QUI_SERA_REMPLACE}/d $LISTE_REPO &&
		echo "${REPO_NAME}:prod:${REPO_DATE}:${REPO_DESCRIPTION}" >> $LISTE_REPO &&
		echo -e "[${VERT} OK ${RESET}]" &&
		echo -ne "Mise à jour des informations dans repos-archive.list :\t" &&
		sed -i /^${REPO_NAME}:${REPO_DATE}/d $LISTE_REPO_ARCHIVE &&
		echo "${REPO_NAME}:${DATE_QUI_SERA_REMPLACE}:Env avant archv. : prod ; Descr. avant archv : ${OLD_DESC_PROD}" >> $LISTE_REPO_ARCHIVE &&
		echo -e "[${VERT} OK ${RESET}]"
	fi
else
    echo -e "\nErreur de syntaxe ou alors il n'existe aucun repo ${CYAN}${REPO_NAME} → ${REPO_DATE}${RESET} sur ce serveur..."
    clean_exit
fi
echo -e "${VERT}Opération terminée${RESET}"
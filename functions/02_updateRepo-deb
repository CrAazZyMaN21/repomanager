#!/bin/bash

# La fonction a besoin de 6 paramètres pour fonctionner :
# Le nom du repo
# Le nom de l'hôte source
# Le nom de la distribution
# Le nom de la section
# Le check gpg si activé ou non
# La signature du repo si activée ou non

# Affichage des arguments passés si le mode debug est activé :
if [ "$DEBUG_MODE" == "enabled" ];then echo "Arguments : $@";fi

while [ $# -ge 1 ];do case "$1" in
	--repo-name)
		REPO_NAME="$2"
		shift
	;;
	--repo-host-name)
		REPO_HOST_NAME="$2"
		shift
	;;
	--repo-dist)
		REPO_DIST="$2"
		shift
	;;
	--repo-section)
		REPO_SECTION="$2"
		shift
	;;
	--gpg-check)
		GPG_CHECK="$2"
		shift
	;;
	--gpg-resign)
		GPG_SIGN_PACKAGES="$2" # on réécrit la variable GPG_SIGN_PACKAGES par ce qui a été transmis
		shift
	;;
	*)
	esac
	shift
done

ERROR="0"

# ICI : il faut rajouter une vérif que l'hote et la racine ne sont pas vides (= non présent dans hosts.conf)

# Si la section est présente dans le fichier repos.list, alors on peut commencer l'opération
if ! egrep -q "^Name=\"${REPO_NAME}\",Host=\"${REPO_HOST_NAME}\",Dist=\"${REPO_DIST}\",Section=\"${REPO_SECTION}\",Env=\"${DEFAULT_ENV}\"" $REPOS_LIST;then
	(( ERROR++ ))
	echo -e "\n[${ROUGE} ERREUR ${RESET}] Il n'existe aucune section ${CYAN}${REPO_SECTION}${RESET} du repo ${CYAN}${REPO_NAME}${RESET} (distribution : ${REPO_DIST}) sur ce serveur."
	MSG_MAIN_ERROR="${MSG_MAIN_ERROR}\n Erreur : Il n'existe aucune section ${REPO_SECTION} du repo ${REPO_NAME} (distribution : ${REPO_DIST}) sur ce serveur"
	if [ "$PLAN_EXEC" -eq "1" ];then # Si cette tâche est exécutée par une planification, alors il faut incrémenter la variable d'erreur utilisée par la fonction planification
		(( PLAN_ERROR++ ))
	fi
fi

# Si la section existe déjà à la date du jour alors on annule l'opération
if egrep -q "^Name=\"${REPO_NAME}\",Host=\"${REPO_HOST_NAME}\",Dist=\"${REPO_DIST}\",Section=\"${REPO_SECTION}\",Env=\"${DEFAULT_ENV}\",Date=\"${DATE_JMA}\"" $REPOS_LIST;then
	(( ERROR++ ))
	echo -e "\n[${ROUGE} ERREUR ${RESET}] La section ${REPO_SECTION} du repo ${REPO_NAME} (distribution ${REPO_DIST}) existe déjà à la date du ${DATE_JMA}."
	MSG_MAIN_ERROR="${MSG_MAIN_ERROR}\n La section ${REPO_SECTION} du repo ${REPO_NAME} (distribution ${REPO_DIST}) existe déjà à la date du ${DATE_JMA}."
	if [ "$PLAN_EXEC" -eq "1" ];then # Si cette tâche est exécutée par une planification, alors il faut incrémenter la variable d'erreur utilisée par la fonction planification
		(( PLAN_ERROR++ ))
	fi
fi

# On traite uniquement si il n'y a pas eu d'erreur précédemment
if [ "$ERROR" -eq "0" ];then
	HOST_FULL_URL=$(grep "^Name=\"${REPO_HOST_NAME}\",Url=" $HOSTS_CONF | awk -F ',' '{print $2}' | cut -d'=' -f2 | sed 's/"//g' ) # Récupère l'url complète
	REPO_HOST=$(echo "$HOST_FULL_URL" | cut -d'/' -f1)
	REPO_RACINE=$(echo "$HOST_FULL_URL" | sed "s/${REPO_HOST}//g") # Extraction de la racine de l'hôte (ex pour : ftp.fr.debian.org/debian ici la racine sera debian
	if [ -z "$REPO_RACINE" ] || [ -z "$REPO_HOST" ];then
		echo -e "[${ROUGE} ERREUR ${RESET}] Adresse de l'hôte incomplète. Vous devez renseigner l'hôte complet avec sa racine (ex : ftp.fr.debian.org/debian) dans votre gestionnaire d'hôtes"
		(( ERROR++ ))
		MSG_MAIN_ERROR="${MSG_MAIN_ERROR}\n Adresse de l'hôte incomplète. Vous devez renseigner l'hôte complet avec sa racine (ex : ftp.fr.debian.org/debian) dans votre gestionnaire d'hôtes"
		if [ "$PLAN_EXEC" -eq "1" ];then # Si cette tâche est exécutée par une planification, alors il faut incrémenter la variable d'erreur utilisée par la fonction planification
			(( PLAN_ERROR++ ))
		fi
	fi
fi

# On continue uniquement si il n'y a pas eu d'erreur précédemment
if [ "$ERROR" -eq "0" ];then
	OLD_DATE_REPO=$(egrep "^Name=\"${REPO_NAME}\",Host=\"${REPO_HOST_NAME}\",Dist=\"${REPO_DIST}\",Section=\"${REPO_SECTION}\",Env=\"${DEFAULT_ENV}\"" $REPOS_LIST | awk -F ',' '{print $6}' | cut -d'=' -f2 | sed 's/"//g')	# On récupère du coup sa date de synchro

	####

	echo -e "\nDébut de l'opération" 
	sleep 2

	####

	echo -ne "Création du répertoire :\t"
	mkdir -p "${REPOS_DIR}/${REPO_NAME}/${REPO_DIST}/${DATE_JMA}_${REPO_SECTION}"
	if [ $? -eq "0" ];then
		echo -e "[${VERT} OK ${RESET}]"
	else
		(( ERROR++ ))
		echo -e "[${ROUGE} ERREUR ${RESET}] Problème lors de la création du répertoire ${REPOS_DIR}/${REPO_NAME}/${REPO_DIST}/${DATE_JMA}_${REPO_SECTION}"
		MSG_MAIN_ERROR="${MSG_MAIN_ERROR}\n Problème lors de la création du répertoire ${REPOS_DIR}/${REPO_NAME}/${REPO_DIST}/${DATE_JMA}_${REPO_SECTION}"
		if [ "$PLAN_EXEC" -eq "1" ];then # Si cette tâche est exécutée par une planification, alors il faut incrémenter la variable d'erreur utilisée par la fonction planification
			(( PLAN_ERROR++ ))
		fi
	fi
fi

# On continue uniquement si il n'y a pas eu d'erreur précédemment
if [ "$ERROR" -eq "0" ];then
	echo -e "Récupération des paquets .deb..."
	sleep 2
	# Dans le cas où on a précisé de ne pas vérifier les signatures GPG
	if [ "$GPG_CHECK" == "no" ];then
		/usr/bin/debmirror --no-check-gpg --nosource --passive --method=http --root=$REPO_RACINE --dist=$REPO_DIST --host=$REPO_HOST --section=$REPO_SECTION --arch=amd64 ${REPOS_DIR}/${REPO_NAME}/${REPO_DIST}/${DATE_JMA}_${REPO_SECTION} --getcontents --ignore-release-gpg --progress --i18n --include='Translation-fr.*\.bz2' --postcleanup #--verbose --debug &&
		RESULT=$?
	else # Dans tous les autres cas (même si rien n'a été précisé)
		/usr/bin/debmirror --check-gpg --keyring=${GPGHOME}/trustedkeys.gpg --nosource --passive --method=http --root=$REPO_RACINE --dist=$REPO_DIST --host=$REPO_HOST --section=$REPO_SECTION --arch=amd64 ${REPOS_DIR}/${REPO_NAME}/${REPO_DIST}/${DATE_JMA}_${REPO_SECTION} --getcontents --ignore-release-gpg --progress --i18n --include='Translation-fr.*\.bz2' --postcleanup #--verbose --debug &&
		RESULT=$?
	fi
	if [ "$RESULT" -eq "0" ];then
		echo -e "\nMise à jour de la section ${REPO_SECTION} du repo ${REPO_NAME} (distribution ${REPO_DIST}) terminée ${VERT}avec succès${RESET}"
	else
		(( ERROR++ ))
		echo -e "[${ROUGE} ERREUR ${RESET}] debmirror a rencontré un problème lors de la création du miroir"
		MSG_MAIN_ERROR="${MSG_MAIN_ERROR}\n debmirror a rencontré un problème lors de la création du miroir"
		if [ "$PLAN_EXEC" -eq "1" ];then # Si cette tâche est exécutée par une planification, alors il faut incrémenter la variable d'erreur utilisée par la fonction planification
			(( PLAN_ERROR++ ))
		fi
		echo -ne "Suppression de ce qui a été fait : "
		rm ${REPOS_DIR}/${REPO_NAME}/${REPO_DIST}/${DATE_JMA}_${REPO_SECTION} -rf &&
		echo -e "[${VERT} OK ${RESET}]"
	fi
fi

if [ "$GPG_SIGN_PACKAGES" == "yes" ];then
	# On va utiliser un répertoire temporaire pour travailler
	TEMP_DIR="/tmp/repomanager_deb_packages"
	mkdir -p "$TEMP_DIR"
	echo -e "\nSignature du repo :"
	cd ${REPOS_DIR}/${REPO_NAME}/${REPO_DIST}/${DATE_JMA}_${REPO_SECTION}/ &&	# On se mets à la racine de la section
	# On recherche tous les paquets .deb et on les déplace dans le répertoire temporaire
	find . -name "*.deb" -exec mv '{}' $TEMP_DIR \;
	# Après avoir déplacé tous les paquets on peut supprimer tout le contenu de la section
	rm -rf ${REPOS_DIR}/${REPO_NAME}/${REPO_DIST}/${DATE_JMA}_${REPO_SECTION}/*
	# Création du répertoire conf et des fichiers de conf du repo
	mkdir -p ${REPOS_DIR}/${REPO_NAME}/${REPO_DIST}/${DATE_JMA}_${REPO_SECTION}/conf
	# Création du fichier "distributions"
	echo -e "Origin: Repo $REPO_NAME sur ${WWW_HOSTNAME}\nLabel: apt repository\nCodename: ${REPO_DIST}\nArchitectures: i386 amd64\nComponents: ${REPO_SECTION}\nDescription: Miroir du repo ${REPO_NAME}, distribution ${REPO_DIST}, section ${REPO_SECTION}\nSignWith: ${GPG_KEYID}\nPull: ${REPO_SECTION}" > conf/distributions
	# Création du fichier "options"
	echo -e "verbose\nbasedir ${REPOS_DIR}/${REPO_NAME}/${REPO_DIST}/${DATE_JMA}_${REPO_SECTION}\nask-passphrase" > conf/options
	# Cration du repo en incluant les paquets deb du répertoire temporaire, et signature du fichier Release
	/usr/bin/reprepro --gnupghome ${GPGHOME} includedeb ${REPO_DIST} ${TEMP_DIR}/*.deb
	if [ $? -eq "0" ];then
		echo -e "\nSection $REPO_SECTION du repo $REPO_NAME ($REPO_DIST) signée ${VERT}avec succès${RESET}"
	else
		(( ERROR++ ))
		echo -e "[ ERREUR ] La signature de la section $REPO_SECTION du repo $REPO_NAME a rencontré une erreur"
		MSG_MAIN_ERROR="$MSG_MAIN_ERROR\n La signature de la section $REPO_SECTION du repo $REPO_NAME a rencontré une erreur"
		if [ "$PLAN_EXEC" -eq "1" ];then # Si cette tâche est exécutée par une planification, alors il faut incrémenter la variable d'erreur utilisée par la fonction planification
			(( PLAN_ERROR++ ))
		fi
		echo -ne "Suppression de ce qui a été fait : "
		rm ${REPOS_DIR}/${REPO_NAME}/${REPO_DIST}/${DATE_JMA}_${REPO_SECTION}/ -rf &&
		echo -e "[ OK ]"
	fi
fi

# On continue uniquement si il n'y a pas eu d'erreur précédemment
if [ "$ERROR" -eq "0" ];then
	echo -ne "Création du lien symbolique :\t\t"
	cd ${REPOS_DIR}/${REPO_NAME}/${REPO_DIST}/ &&  # Retour au répertoire de base pour traiter la suite
	unlink ${REPO_SECTION}_${DEFAULT_ENV} # Supression du lien symbolique pointant sur l'ancienne version du repo
	ln -sf ${DATE_JMA}_${REPO_SECTION}/ ${REPO_SECTION}_${DEFAULT_ENV}	# Puis création du nouveau, pointant sur la nouvelle version à la date du jour
	if [ $? -eq "0" ];then
		echo -e "[${VERT} OK ${RESET}]"
	else
		(( ERROR++ ))
		echo -e "[${ROUGE} ERREUR ${RESET}] pendant la création du lien symbolique"
		MSG_MAIN_ERROR="${MSG_MAIN_ERROR}\n Erreur pendant la création du lien symbolique"
		if [ "$PLAN_EXEC" -eq "1" ];then # Si cette tâche est exécutée par une planification, alors il faut incrémenter la variable d'erreur utilisée par la fonction planification
			(( PLAN_ERROR++ ))
		fi
	fi
fi

# On continue uniquement si il n'y a pas eu d'erreur précédemment
if [ "$ERROR" -eq "0" ];then
	# Si l'ancienne version n'est pas utilisée par un autre environnement alors on l'archive. Pour cela on affiche toutes les lignes contenant notre repo, et on retire celle contenant Env=${DEFAULT_ENV} afin d'afficher tous les autres éventuels envs qui utilisent ce repo (si il y en a)
	if ! egrep "^Name=\"${REPO_NAME}\",Host=\".*\",Dist=\"${REPO_DIST}\",Section=\"${REPO_SECTION}\",Env=\".*\",Date=\"${OLD_DATE_REPO}\"" $REPOS_LIST | grep -v -q "Env=\"${DEFAULT_ENV}\"";then
		echo "La version précédente du ${OLD_DATE_REPO} n'est pas utilisée par d'autres environnements (donc elle n'est plus utilisée)"
		OLD_DESCRIPTION=$(egrep "^Name=\"${REPO_NAME}\",Host=\".*\",Dist=\"${REPO_DIST}\",Section=\"${REPO_SECTION}\",Env=\"${DEFAULT_ENV}\"" "$REPOS_LIST" | awk -F',' '{print $7}' | cut -d'=' -f2 | sed 's/"//g')
		OLD_HOST_NAME=$(egrep "^Name=\"${REPO_NAME}\",Host=\".*\",Dist=\"${REPO_DIST}\",Section=\"${REPO_SECTION}\",Env=\"${DEFAULT_ENV}\"" "$REPOS_LIST" | awk -F',' '{print $2}' | cut -d'=' -f2 | sed 's/"//g') # on récupère aussi l'ancien hote au cas où il soit différent 
		echo -ne "Archivage de l'ancienne version :\t"
		cd ${REPOS_DIR}/${REPO_NAME}/${REPO_DIST}/ &&
		mv "${OLD_DATE_REPO}_${REPO_SECTION}/" "archived_${OLD_DATE_REPO}_${REPO_SECTION}/" # On renomme l'ancienne version en tant que old_prod_JJ-MM-AAAA_base/
		echo -e "[${VERT} OK ${RESET}]"
		echo -ne "Mise à jour des informations dans repos-archive.list :\t"
		echo "Name=\"${REPO_NAME}\",Host=\"${OLD_HOST_NAME}\",Dist=\"${REPO_DIST}\",Section=\"${REPO_SECTION}\",Date=\"${OLD_DATE_REPO}\",Description=\"${OLD_DESCRIPTION}\"" >> $REPOS_ARCHIVE_LIST
		echo -e "[${VERT} OK ${RESET}]"
	fi

	####

	echo -ne "Mise à jour des informations dans repos.list :\t"
	sed -i "s|^Name=\"${REPO_NAME}\",Host=\".*\",Dist=\"${REPO_DIST}\",Section=\"${REPO_SECTION}\",Env=\"${DEFAULT_ENV}\",Date=\"${OLD_DATE_REPO}\"|Name=\"${REPO_NAME}\",Host=\"${REPO_HOST_NAME}\",Dist=\"${REPO_DIST}\",Section=\"${REPO_SECTION}\",Env=\"${DEFAULT_ENV}\",Date=\"${DATE_JMA}\"|g" $REPOS_LIST &&  # On mets à jour les infos dans le fichier repos.list (par exemple)
	if [ $? -eq "0" ];then
		echo -e "[${VERT} OK ${RESET}]"
	else
		(( ERROR++ ))
		echo -e "[${ROUGE} ERREUR ${RESET}] pendant l'ajout des informations"
		MSG_MAIN_ERROR="${MSG_MAIN_ERROR}\n Erreur pendant l'ajout des informations"
		if [ "$PLAN_EXEC" -eq "1" ];then # Si cette tâche est exécutée par une planification, alors il faut incrémenter la variable d'erreur utilisée par la fonction planification
			(( PLAN_ERROR++ ))
		fi
	fi
fi

# On continue uniquement si il n'y a pas eu d'erreur précédemment
if [ "$ERROR" -eq "0" ];then
	echo -ne "Application des droits sur la section créée :\t"
	find ${REPOS_DIR}/${REPO_NAME}/${REPO_DIST}/${DATE_JMA}_${REPO_SECTION}/ -type f -exec chmod 0660 {} \;
	find ${REPOS_DIR}/${REPO_NAME}/${REPO_DIST}/${DATE_JMA}_${REPO_SECTION}/ -type d -exec chmod 0770 {} \;
	echo -e "[${VERT} OK ${RESET}]"

	echo -e "${VERT}Opération terminée${RESET}"
fi
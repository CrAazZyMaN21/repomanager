#!/bin/bash
# Suppression d'un repo (Redhat/Centos) ou d'une section de repo (Debian)

#	Format des liens sources Debian :
#	deb http://ftp.fr.debian.org/debian   stretch    main
#	    ‾‾‾‾‾‾‾‾‾‾‾‾‾‾|‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾   ‾‾‾|‾‾‾    ‾‾|‾
#	        Hôte source et racine       Distribution  Section (main, contrib...)
# Signer des repos sous Debian : https://wiki.debian.org/DebianRepository/SetupWithReprepro

# La fonction a besoin des paramètres suivants pour fonctionner 
# Le nom du repo
# Le nom de l'hôte source (debian)
# Le nom du repo source (redhat/cecntos)
# Le nom de la distribution (debian)
# Le nom de la section (debian)
# Le check gpg si activé ou non
# La signature GPG du repo si activé ou non
# La description (peut être vide)

# Affichage des arguments passés si le mode debug est activé :
if [ "$DEBUG_MODE" == "enabled" ];then echo "Arguments : $@";fi

while [ $# -ge 1 ];do case "$1" in
	--repo-name)
		REPO_NAME="$2"
		shift
	;;
	--repo-real-name)
		REPO_REALNAME="$2"
		shift
	;;
	--repo-host-name)
		REPO_HOST_NAME="$2"
		shift
	;;
	--repo-dist)
		REPO_DIST="$2"
		shift
	;;
	--repo-section)
		REPO_SECTION="$2"
		shift
	;;
	--gpg-check)
		GPG_CHECK="$2"
		shift
	;;
	--gpg-resign)
		GPG_SIGN_PACKAGES="$2" # on réécrit la variable GPG_SIGN_PACKAGES par ce qui a été transmis
		shift
	;;
	--repo-description)
		# on shift un coup pour récupérer tous les derniers arguments $* (la description pouvant contenir des espaces, chaque espace est un nouvel argument, c'est pour ça qu'on récupère tout)
		shift
		REPO_DESCRIPTION="$*"
	;;
	*)
	esac
	shift
done
if [ "$REPO_DESCRIPTION" == "nodescription" ];then REPO_DESCRIPTION="";fi # Si la description est égale à 'nodescription' alors elle doit être laissée vide

if [ "$OS_FAMILY" == "Redhat" ];then echo "<h1>CREATION D'UN NOUVEAU REPO</h1>";fi
if [ "$OS_FAMILY" == "Debian" ];then echo "<h1>CREATION D'UNE NOUVELLE SECTION DE REPO</h1>";fi

# Récupération d'informations supplémentaires
if [ "$OS_FAMILY" == "Debian" ];then
	HOST_FULL_URL=$(grep "^Name=\"${REPO_HOST_NAME}\",Url=" $HOSTS_CONF | awk -F ',' '{print $2}' | cut -d'=' -f2 | sed 's/"//g') # Récupère l'url complète
	REPO_HOST=$(echo "$HOST_FULL_URL" | cut -d'/' -f1)
	# Extraction de la racine de l'hôte (ex pour : ftp.fr.debian.org/debian ici la racine sera debian
	REPO_RACINE=$(echo "$HOST_FULL_URL" | sed "s/${REPO_HOST}//g")
	if [ -z "$REPO_HOST" ];then echo "<br>Erreur : impossible de déterminer l'adresse de l'hôte source";clean_exit;fi
	if [ -z "$REPO_RACINE" ];then echo "<br>Erreur : impossible de déterminer la racine de l'URL hôte";clean_exit;fi
fi

# Affichage du récapitulatif de l'opération
echo "<p><b>DÉTAILS</b></p>"
echo "<table>"
if [ "$OS_FAMILY" == "Redhat" ];then
	echo "
	<tr>
		<td><b>Repo source</b></td>
		<td>$REPO_REALNAME</td>
	</tr>
	<tr>
		<td><b>Nom du repo</b></td>
		<td>$REPO_NAME</td>
	</tr>"
fi
if [ "$OS_FAMILY" == "Debian" ];then
	echo "
	<tr>
		<td><b>Hôte source</b></td>
		<td>$HOST_FULL_URL</td>
	</tr>
	<tr>
		<td><b>Nom du repo</b></td>
		<td>$REPO_NAME</td>
	</tr>
	<tr>
		<td><b>Distribution</b></td>
		<td>$REPO_DIST</td>
	</tr>
	<tr>
		<td><b>Section</b></td>
		<td>$REPO_SECTION</td>
	</tr>"
fi
echo "<tr>
		<td><b>Vérification des signatures GPG</b></td>
		<td>$GPG_CHECK</td>
	</tr>
	<tr>
		<td><b>Signature du repo</b></td>
		<td>$GPG_SIGN_PACKAGES</td>
	</tr>
</tr>"
echo "</table>"


## VERIFICATIONS ##

# On vérifie quand même que le repo n'existe pas déjà :
if [ "$OS_FAMILY" == "Redhat" ];then
	if egrep -q "^Name=\"${REPO_NAME}\",Realname=\"${REPO_REALNAME}\",Env=\"${DEFAULT_ENV}\"" "$REPOS_LIST";then 
		echo "<span class=\"text-red\">Erreur : le repo $REPO_NAME existe déjà en ${DEFAULT_ENV} !</span>"
		clean_exit
	fi
fi
if [ "$OS_FAMILY" == "Debian" ];then
	if egrep -q "^Name=\"${REPO_NAME}\",Host=\"${REPO_HOST_NAME}\",Dist=\"${REPO_DIST}\",Section=\"${REPO_SECTION}\,Env=\"${DEFAULT_ENV}\"" "$REPOS_LIST";then 
		echo "<span class=\"text-red\">Erreur : la section $REPO_SECTION du repo $REPO_NAME existe déjà en ${DEFAULT_ENV} !</span>"
		clean_exit
	fi
fi


## TRAITEMENT ##

echo "<h3>Début de l'opération</h3>"
# Création du répertoire du repo/section
if [ "$OS_FAMILY" == "Redhat" ];then
	if ! mkdir -p "${REPOS_DIR}/${DATE_JMA}_${REPO_NAME}";then
		echo "<br>Erreur lors de la création du répertoire ${REPOS_DIR}/${DATE_JMA}_${REPO_NAME}"
		clean_exit
	fi
fi
if [ "$OS_FAMILY" == "Debian" ];then
	if ! mkdir -p "${REPOS_DIR}/${REPO_NAME}/${REPO_DIST}/${DATE_JMA}_${REPO_SECTION}";then
		echo "<br>Erreur lors de la création du répertoire ${REPOS_DIR}/${REPO_NAME}/${REPO_DIST}/${DATE_JMA}_${REPO_SECTION}"
		clean_exit
	fi
fi

# Récupération des paquets
if [ "$OS_FAMILY" == "Redhat" ];then
	echo '<br>Récupération des paquets .rpm <img src="images/loading.gif" class="icon" />'
	cd "${REPOS_DIR}/${DATE_JMA}_${REPO_NAME}"/ &&
	if [ "$GPG_CHECK" == "no" ];then
		if [ "$OS_VERSION" == "7" ];then
			reposync --config=${REPOMANAGER_YUM_DIR}/repomanager.conf -l --repoid=${REPO_REALNAME} --norepopath --download_path="${REPOS_DIR}/${DATE_JMA}_${REPO_NAME}/"
			RESULT=$?
		fi
		if [ "$OS_VERSION" == "8" ];then
			reposync --config=${REPOMANAGER_YUM_DIR}/repomanager.conf --nogpgcheck --repoid=${REPO_REALNAME} --download-path "${REPOS_DIR}/${DATE_JMA}_${REPO_NAME}/"
			RESULT=$?
		fi
	else # Dans tous les autres cas (même si rien n'a été précisé) on active gpgcheck
		if [ "$OS_VERSION" == "7" ];then
			reposync --config=${REPOMANAGER_YUM_DIR}/repomanager.conf --gpgcheck -l --repoid=${REPO_REALNAME} --norepopath --download_path="${REPOS_DIR}/${DATE_JMA}_${REPO_NAME}/"
			RESULT=$?
		fi
		if [ "$OS_VERSION" == "8" ];then
			reposync --config=${REPOMANAGER_YUM_DIR}/repomanager.conf --repoid=${REPO_REALNAME} --download-path "${REPOS_DIR}/${DATE_JMA}_${REPO_NAME}/"
			RESULT=$?
		fi
	fi
	if [ "$RESULT" -eq "0" ];then
		echo " ✔ "
	else
		echo "<br>Erreur : reposync a rencontré un problème lors de la création du miroir"
		echo -ne "Suppression de ce qui a été fait : "
		rm "${REPOS_DIR}/${DATE_JMA}_${REPO_NAME}" -rf &&
		echo "OK"
		clean_exit
	fi
fi
if [ "$OS_FAMILY" == "Debian" ];then
	echo '<br>Récupération des paquets .deb <img src="images/loading.gif" class="icon" />'
	#cd "${REPOS_DIR}/${REPO_NAME}"/ &&
	# Dans le cas où on a précisé de ne pas vérifier les signatures GPG :
	if [ "$GPG_CHECK" == "no" ];then
		/usr/bin/debmirror --no-check-gpg --nosource --passive --method=http --root=${REPO_RACINE} --dist=${REPO_DIST} --host=${REPO_HOST} --section=${REPO_SECTION} --arch=amd64 ${REPOS_DIR}/${REPO_NAME}/${REPO_DIST}/${DATE_JMA}_${REPO_SECTION} --getcontents --ignore-release-gpg --progress --i18n --include='Translation-fr.*\.bz2' --postcleanup >/dev/null 2>/dev/null
		RESULT=$?
	else # Dans tous les autres cas (même si rien n'a été précisé)
		/usr/bin/debmirror --check-gpg --keyring=${GPGHOME}/trustedkeys.gpg --nosource --passive --method=http --root=${REPO_RACINE} --dist=${REPO_DIST} --host=${REPO_HOST} --section=${REPO_SECTION} --arch=amd64 ${REPOS_DIR}/${REPO_NAME}/${REPO_DIST}/${DATE_JMA}_${REPO_SECTION} --getcontents --ignore-release-gpg --progress --i18n --include='Translation-fr.*\.bz2' --postcleanup >/dev/null 2>/dev/null
		RESULT=$?
	fi
	if [ "$RESULT" -eq "0" ];then
		echo " ✔ "
	else
		echo "<br>Erreur : debmirror a rencontré un problème lors de la création du miroir"
		echo -ne "<br>Suppression de ce qui a été fait : "
		rm "${REPOS_DIR}/${REPO_NAME}/${REPO_DIST}/${DATE_JMA}_${REPO_SECTION}" -rf &&
		echo "OK"
		clean_exit
	fi
fi

# Signature des paquets/du repo avec GPG
# Si c'est Redhat/Centos on resigne les paquets
# Si c'est Debian on signe le repo (Release.gpg)
if [ "$GPG_SIGN_PACKAGES" == "yes" ];then
	if [ "$OS_FAMILY" == "Redhat" ];then
		echo "<br>Signature des paquets (GPG) "
		# On se mets à la racine du repo
		cd "${REPOS_DIR}/${DATE_JMA}_${REPO_NAME}"/ &&
		# Activation de globstar (**), cela permet à bash d'aller chercher des fichiers .rpm récursivement, peu importe le nb de sous-répertoires
		shopt -s globstar
		if [ -f "/usr/bin/rpmresign" ];then
			#/usr/bin/rpmresign --path "$GPGHOME" --passwordfile "$PASSPHRASE_FILE" **/*.rpm        # Si le module rpmresign est installé, on l'utilise (signature automatique en utilisant un fichier passphrase	
			/usr/bin/rpmresign --path "${GPGHOME}" --name "${GPG_KEYID}" --passwordfile "${PASSPHRASE_FILE}" **/*.rpm
			RESULT=$?
			#/usr/bin/rpmresign --macros $RPMMACROS --path $GPGHOME --passwordfile "$PASSPHRASE_FILE" **/*.rpm        # Si le module rpmresign est installé, on l'utilise (signature automatique en utilisant un fichier passphrase
		else
			rpmsign --addsign **/*.rpm	# Sinon on utilise rpmsign et on demande le mdp à l'utilisateur (pas possible d'utiliser un fichier passphrase)
			RESULT=$?
		fi
		if [ "$RESULT" -eq "0" ];then
			# Désactivation de globstar
			shopt -u globstar
			echo "✔"
		else
			echo "Erreur : la signature des paquets a échouée"
			echo -ne "<br>Suppression de ce qui a été fait : "
			rm "${REPOS_DIR}/${DATE_JMA}_${REPO_NAME}" -rf &&
			echo "OK"
			clean_exit
		fi
	fi
	if [ "$OS_FAMILY" == "Debian" ];then
		# On va utiliser un répertoire temporaire pour travailler
		TEMP_DIR="/tmp/repomanager_deb_packages"
		mkdir -p "$TEMP_DIR"
		echo "<br>Signature du repo (GPG) "
		cd ${REPOS_DIR}/${REPO_NAME}/${REPO_DIST}/${DATE_JMA}_${REPO_SECTION}/ &&	# On se mets à la racine de la section
		# On recherche tous les paquets .deb et on les déplace dans le répertoire temporaire
		find . -name "*.deb" -exec mv '{}' $TEMP_DIR \;
		# Après avoir déplacé tous les paquets on peut supprimer tout le contenu de la section
		rm -rf ${REPOS_DIR}/${REPO_NAME}/${REPO_DIST}/${DATE_JMA}_${REPO_SECTION}/*
		# Création du répertoire conf et des fichiers de conf du repo
		mkdir -p ${REPOS_DIR}/${REPO_NAME}/${REPO_DIST}/${DATE_JMA}_${REPO_SECTION}/conf
		# Création du fichier "distributions"
		echo -e "Origin: Repo $REPO_NAME sur ${WWW_HOSTNAME}\nLabel: apt repository\nCodename: ${REPO_DIST}\nArchitectures: i386 amd64\nComponents: ${REPO_SECTION}\nDescription: Miroir du repo ${REPO_NAME}, distribution ${REPO_DIST}, section ${REPO_SECTION}\nSignWith: ${GPG_KEYID}\nPull: ${REPO_SECTION}" > conf/distributions
		# Création du fichier "options"
		echo -e "basedir ${REPOS_DIR}/${REPO_NAME}/${REPO_DIST}/${DATE_JMA}_${REPO_SECTION}\nask-passphrase" > conf/options
		# Cration du repo en incluant les paquets deb du répertoire temporaire, et signature du fichier Release
		/usr/bin/reprepro --gnupghome ${GPGHOME} --silent includedeb ${REPO_DIST} ${TEMP_DIR}/*.deb
		if [ $? -eq "0" ];then
			echo "✔"
		else
			echo "Erreur : la signature de la section $REPO_SECTION du repo $REPO_NAME a échouée"
			echo -ne "<br>Suppression de ce qui a été fait : "
			rm "${REPOS_DIR}/${REPO_NAME}/${REPO_DIST}/${DATE_JMA}_${REPO_SECTION}" -rf &&
			echo "OK"
			clean_exit
		fi
	fi
fi

# Création des metadata du repo (Redhat/centos uniquement)
if [ "$OS_FAMILY" == "Redhat" ];then
	echo "<br>Création du dépôt (metadata) "
	createrepo -v ${REPOS_DIR}/${DATE_JMA}_${REPO_NAME}/
	if [ $? -eq "0" ];then
		echo "✔"
	else
		echo "Erreur lors de la création du repo"
		echo -ne "Suppression de ce qui a été fait : "
		rm ${REPOS_DIR}/${DATE_JMA}_${REPO_NAME}/ -rf &&
		echo "OK"
		clean_exit
	fi
fi

# Création du lien symbolique (environnement)
if [ "$OS_FAMILY" == "Redhat" ];then
	cd ${REPOS_DIR}/ &&
	ln -s ${DATE_JMA}_${REPO_NAME}/ ${REPO_NAME}_${DEFAULT_ENV}
	if [ $? -ne "0" ];then
		echo "<br>Erreur pendant la finalisation du repo"
		clean_exit
	fi
fi
if [ "$OS_FAMILY" == "Debian" ];then
	cd ${REPOS_DIR}/${REPO_NAME}/${REPO_DIST}/ &&
	ln -sf ${DATE_JMA}_${REPO_SECTION}/ ${REPO_SECTION}_${DEFAULT_ENV}
	if [ $? -ne "0" ];then
		echo "<br>Erreur pendant la finalisation du repo"
		clean_exit
	fi
fi

# Ajout des informations dans repos.list
if [ "$OS_FAMILY" == "Redhat" ];then
	echo "Name=\"${REPO_NAME}\",Realname=\"${REPO_REALNAME}\",Env=\"${DEFAULT_ENV}\",Date=\"${DATE_JMA}\",Description=\"${REPO_DESCRIPTION}\"" >> $REPOS_LIST # On mets à jour les infos dans le fichier repos.list (par exemple)
	if [ $? -ne "0" ];then
		echo "Erreur lors de l'ajout du repo $REPO_NAME à la liste des repos actifs"
		clean_exit
	fi
fi
if [ "$OS_FAMILY" == "Debian" ];then
	echo "Name=\"${REPO_NAME}\",Host=\"${REPO_HOST_NAME}\",Dist=\"${REPO_DIST}\",Section=\"${REPO_SECTION}\",Env=\"${DEFAULT_ENV}\",Date=\"${DATE_JMA}\",Description=\"${REPO_DESCRIPTION}\"" >> $REPOS_LIST # On mets à jour les infos dans le fichier repos.list (par exemple)
	if [ $? -ne "0" ];then
		echo "Erreur lors de l'ajout de la section $REPO_SECTION du repo $REPO_NAME à la liste des repos actifs"
		clean_exit
	fi
fi

# Application des droits sur le repo/section créé
if [ "$OS_FAMILY" == "Redhat" ];then
	find ${REPOS_DIR}/${DATE_JMA}_${REPO_NAME}/ -type f -exec chmod 0660 {} \; &&
	find ${REPOS_DIR}/${DATE_JMA}_${REPO_NAME}/ -type d -exec chmod 0770 {} \;
	if [ $? -ne "0" ];then
		echo "<br>Erreur pendant l'application des permissions sur le repo $REPO_NAME"
	fi
fi
if [ "$OS_FAMILY" == "Debian" ];then
	find ${REPOS_DIR}/${REPO_NAME}/${REPO_DIST}/${DATE_JMA}_${REPO_SECTION}/ -type f -exec chmod 0660 {} \; &&
	find ${REPOS_DIR}/${REPO_NAME}/${REPO_DIST}/${DATE_JMA}_${REPO_SECTION}/ -type d -exec chmod 0770 {} \;
	if [ $? -ne "0" ];then
		echo "<br>Erreur pendant l'application des permissions sur la section $REPO_SECTION"
	fi
fi

# Génération du fichier de conf repo en local (ces fichiers sont utilisés pour les profils)
if [ "$OS_FAMILY" == "Redhat" ];then generateConf --repo-name ${REPO_NAME};fi
if [ "$OS_FAMILY" == "Debian" ];then generateConf --repo-name ${REPO_NAME} --repo-dist ${REPO_DIST} --repo-section ${REPO_SECTION};fi

echo "<br>Opération terminée<br>"